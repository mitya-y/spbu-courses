% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

В предыдущей работе~\cite{PrevWork} используется алгоритм \ref{AlgoCode} достижимости в графе с регулярными ограничениями, его реализация на языке программирования \textsc{C++}, основанная на библиотеке cuBool~\cite{CuBool}, представлена в GitHub репозитории\footnote{\href{https://github.com/mitya-y/rpq/tree/cb2583e64e51f28dfe16f8e2b66732bc44bb04d5}{Код} реализации алгоритма на GPU, представленный в предыдущей работе (Дата доступа: 19.06.2025)}.

\begin{algorithm}[H]
    \caption{Алгоритм достижимости в графе с регулярными ограничениями на основе поиска в ширину, выраженного с помощью операций матричного умножения}
    \label{AlgoCode}
    \begin{algorithmic}[1]
        \Procedure{BFSBasedRPQ}{$D = \langle Q, q_S, Q_F, \delta, \Sigma \rangle,G=\langle V, E, L \rangle, V_{src}$}
            \State $\mathcal{D}^a\gets $ Матрица смежности ДКА для символа $a$
            \State $\mathcal{G}^a\gets $ Матрица смежности графа для символа $a$
            \State $\mathcal{F}\gets $ Вектор финальных состояний автомата $D$
            \State $M\gets$ Матрица $|Q| \times |V|$ \Comment Матрица обхода
            \State $P\gets$ Матрица $|Q| \times |V|$ \Comment Матрица с посещёнными состояниями
            \State $M'\gets$ Матрица $|Q| \times |V|$ с вершинами из $V_{src}$, соответствующими $q_S$

            \While{$M'$ ненулевая}{}
                \State $M\gets M'$
                \State $M'\gets$ Пустая матрица
                \ForAll{$a\in (\Sigma \cap L)$}
                    \If{$a$ начинается не с $\^{}$}
                        \State $M'\gets M' + (\mathcal{D}^a)^T \times (M \times \langle \neg P \rangle \mathcal{G}^a)$ \Comment{Умножение с маской}
                    \Else
                        \State $M'\gets M' + (\mathcal{D}^a)^T \times (M \times \langle \neg P \rangle (\mathcal{G}^a)^T)$
                    \EndIf
                \EndFor
                \State $P\gets P + M'$ \Comment{Аккумулирование достигнутых состояний}
                \State $\mathcal{P}\gets \mathcal{P} + \mathcal{F} \times M'$ \Comment{Поиск финальных состояний}
            \EndWhile
            \State \textbf{return} $\mathcal{P}$
        \EndProcedure
    \end{algorithmic}
    \label{final-algo}
\end{algorithm}

Список входных параметров перечислен ниже.
\begin{itemize}
    \item Конечный автомат, построенный по регулярному ограничению (существуют алгоритмы преобразования), состоящий из графа переходов $Q$, начальных ($q_S$) и конечных ($Q_F$) состояний, а так же алфавита $\delta$ и языка $\Sigma$ на котором построено регулярное ограничение. 
    \item Граф, состоящий из множества вершин $V$, множества ребер с метками $E$ и множества допустимых меток $L$.
    \item Начальные вершины графа --- $V_{src}$.
\end{itemize}

Граф декомпозируются по меткам (для каждой метки выделяется граф, состоящий из тех же вершин, что и начальный граф, но из ребер начального графа берутся только ребра с этой меткой), и создаётся множество матриц смежности для каждого получившегося графa $\mathcal{D}^a$. Такая же операция применяется и к графу конечного автомата $\mathcal{G}$.

Далее создаются матрицы, которые будут обновляться каждый шаг алгоритма и хранить текущее состояние: все достижимые вершины на данном шаге алгоритма. Это матрицы обхода $M$ и $M'$, одна пустая (так как на первом же шаге цикла в нее будет записано другое значение), а вторая заполняется следующим образом: для каждого начального состояния конечного автомата все начальные вершины графа помечаются достижимыми.
Так же создается матрица всех посещенных состояний $P$, чтобы в дальнейшем избежать лишних итераций цикла алгоритма.

Основная часть алгоритма --- это обход поиском в ширину, который происходит с использованием умножения матриц. Он продолжается, пока матрица обхода c предыдущего шага $M'$ ненулевая. Каждый шаг матрица обхода с предыдущего шага сохраняется, матрица обхода текущего шага заполняется нулями.

На каждом шагу обхода алгоритм проходит по всем исходящим из вершин, достигнутых на предыдущем шаге, ребрам для каждой метки, одновременно обходится и конечный автомат. Это происходит следующим образом: к матрице обхода состояния $M'$ для каждой метки $a$ аккумулируются состояния, получающиеся из вершин прошлого состояния, которые еще не были посещены (это достигается при помощи умножения на маску посещенных состояний $P$), проходя по ребру, если оно есть и в графе (умножение на $\mathcal{G}^a$), и в графе конечного автомата (умножаем на $\mathcal{D}^a$ на результат прохода по ребру графа). Если по ребру требуется пройти в обратную сторону, то используется транспонированную матрицу графа $(\mathcal{G}^a)^T$ (доказательство корректности операции можно найти в работе в пункте 3.1). 

После этого мы обновляем матрицу посещенных состояний $P$ и вектор достижимых вершин $\mathcal{P}$ (дописываем в него, в какой вершине мы достигли какого-то финального состояния конечного автомата).  

Результатом алгоритма является вектор достижимых вершин $\mathcal{P}$.

\subsection{Библиотека cuBool}
В этом разделе будет более подробно рассмотрена библиотека cuBool, ее возможности и недостатки.

В cuBool представлены почти все операции булевой линейной алгебры для векторов и матриц. Для матриц это транспонирование, сложение, умножение, как обычное, так и поэлементное, операция взятия столбца или строки как вектор, сложение всех строк, а также произведение Кронекера. Что очень важно, есть операция получения количества ненулевых элементов, и при этом она работает за $O(1)$. Для векторов же это сложение и умножение как вектора на матрицу, так и матрицы на вектор.

Все матрицы в cuBool разреженные, и используется следующий формат хранения: для каждой матрицы хранится множество пар индексов с ненулевыми значениями.  

Для реализации данных операций данная библиотека использует вычислительное API CUDA\footnote{API CUDA: \url{https://developer.nvidia.com/cuda-toolkit} (Дата доступа: 19.06.2025)} от Nvidia, а точнее говоря библиотеку thrust, написанную на CUDA самими разработчиками. Полная и доступная документация thrust\footnote{Документация thrust: \url{https://nvidia.github.io/cccl/thrust/} (Дата доступа: 19.06.2025)} делает разработку на ней быстрой и приятной, а код становится простым для восприятия.

В cuBool есть поддержка операций, выполняемых на CPU без использования параллельных вычислений, что, конечно, не дает желаемой производительности, но позволяет запускаться на платформах, на которых нет графического ускорителя.

Также в cuBool есть удобная система логгирования, сильно облегчающая отладку, а также слежение за выделенной памятью, что помогает избежать её утечек.

\subsection{Поэлементное сложение разреженных булевых матриц} \label{MatrixAddSection}

В ходе изучения производительности алгоритма было обнаружено, что операция сложения матриц занимает много времени
%, хотя по сложности она не сложнее операции поэлементного умножения на инвертированную матрицу. Поэтому
, поэтому
необходимо изучить, как можно реализовать эту операцию.

Пусть $C = A + B$. Рассмотрим пример сложения булевых матриц.

\begin{align*}
\begin{pmatrix}
  1 & 0 & 0 & 1  \\
  1 & 0 & 0 & 0  \\
  0 & 0 & 1 & 1  \\
  1 & 0 & 0 & 0  \\
\end{pmatrix}
+
\begin{pmatrix}
  1 & 0 & 0 & 0  \\
  0 & 1 & 1 & 0  \\
  1 & 0 & 0 & 0  \\
  0 & 0 & 0 & 1  \\
\end{pmatrix}
=
\begin{pmatrix}
  1 & 0 & 0 & 1  \\
  1 & 1 & 1 & 0  \\
  1 & 0 & 1 & 1  \\
  1 & 0 & 0 & 1  \\
\end{pmatrix}
\end{align*}

 Для каждого элемента итоговой матрицы легко понять, какое значение у него будет. На примере видно, что элемент матрицы равен единице, если хотя бы у одной из складываемых матриц соответствующий элемент тоже равен единице.
$$
C_{ij} = 1
\Longleftrightarrow
A_{ij} = 1 \lor B_{ij} = 1
$$

Один из оптимальных по памяти форматов представления разреженных матриц это множество пар индексов, в которых элементы отличны от 0. И чтобы вычислить результат поэлементного сложения надо узнать все пары индексов, которые есть хотя бы в одной из исходных матриц, то есть нужно объединить множества индексов с ненулевыми элементам матриц.
