% !TeX spellcheck = ru_RU
% !TEX root = vkr.tex

\section{Обзор}
\label{sec:relatedworks}

% \subsection{Выбранная реализация алгоритма}

У алгоритма достижимости с регулярными ограничениями есть довольно много реализаций, из популярных можно назвать реализации в больших графовых базах данных с открытым кодом
MilleniumDB\footnote{Реализация RPQ в MilleniumDB: \url{https://github.com/MillenniumDB/MillenniumDB/tree/main/src/query/executor/binding_iter/paths/all_shortest_simple} (Дата посещения: 08.01.2025)} и
FalcorDB\footnote{Реализация RPQ в FalcorDB: \url{https://github.com/FalkorDB/FalkorDB/blob/master/src/algorithms/all_shortest_paths.c} (Дата посещения: 08.01.2025)}.

Но для реализации на GPU был выбран алгоритм, предложенный Георгием Беляниным в работе \cite{OldRpqVkr}. Реализация этого алгоритма на CPU от автора работы представлена в GitHub репозитории\footnote{Реализация алгоритма RPQ: \url{https://github.com/SparseLinearAlgebra/LAGraph/tree/2-rpq} (Дата посещения: 08.01.2025)}. Она реализованна на базе библиотеки линейной алгебры для разреженных матриц SuiteSparse ~\cite{SuiteSparse} в форке репозитория LaGraph, где собраны алгоритмы на базе этой библиотеки.

Причины, по которым была выбрана именно она, перечислены ниже.
\begin{itemize}
    \item Она основана на операциях булевой линейной алгебры и использует большие разреженные матрицы, а вычисления этих операций отлично подходят для огромной параллельной вычислительной мощности видеокарт.
    \item Есть поддержка двухсторонниx запросов.
    \item В библиотеке SuiteParse ведется разработка поддержки вычислений на GPU, так что потенциально именно эта реализация может стать главным конкурентом по производительности.
    \item В работе~\cite{rpq-article-cool} есть тесты производительности, которые говорят о том, что алгоритм работает быстрее своих конкурентов.
\end{itemize}

В работе можно найти следующий псевдокод алгоритма (\ref{AlgoCode}).

\begin{algorithm}[H]
    \caption{Алгоритм достижимости в графе с регулярными ограничениями на основе поиска в ширину, выраженного с помощью операций матричного умножения}
    \label{AlgoCode}
    \begin{algorithmic}[1]
        \Procedure{BFSBasedRPQ}{$D = \langle Q, q_S, Q_F, \delta, \Sigma \rangle,G=\langle V, E, L \rangle, V_{src}$}
            \State $\mathcal{D}^a\gets $ Матрица смежности ДКА для символа $a$
            \State $\mathcal{G}^a\gets $ Матрица смежности графа для символа $a$
            \State $\mathcal{F}\gets $ Вектор финальных состояний автомата $D$
            \State $M\gets$ Матрица $|Q| \times |V|$ \Comment Матрица обхода
            \State $P\gets$ Матрица $|Q| \times |V|$ \Comment Матрица с посещёнными состояниями
            \State $M'\gets$ Матрица $|Q| \times |V|$ с вершинами из $V_{src}$, соответствующими $q_S$

            \While{$M'$ ненулевая}{}
                \State $M\gets M'$
                \State $M'\gets$ Пустая матрица
                \ForAll{$a\in (\Sigma \cap L)$}
                    \If{$a$ начинается не с $\^{}$}
                        \State $M'\gets M' + (\mathcal{D}^a)^T \times (M \times \langle \neg P \rangle \mathcal{G}^a)$ \Comment{Умножение с маской}
                    \Else
                        \State $M'\gets M' + (\mathcal{D}^a)^T \times (M \times \langle \neg P \rangle (\mathcal{G}^a)^T)$
                    \EndIf
                \EndFor
                \State $P\gets P + M'$ \Comment{Аккумулирование достигнутых состояний}
                \State $\mathcal{P}\gets \mathcal{P} + \mathcal{F} \times M'$ \Comment{Поиск финальных состояний}
            \EndWhile
            \State \textbf{return} $\mathcal{P}$
        \EndProcedure
    \end{algorithmic}
    \label{final-algo}
\end{algorithm}

Список входных параметров перечислен ниже.
\begin{itemize}
    \item Конечный автомат, построенный по регулярному ограничению (существуют алгоритмы преобразования), состоящий из графа переходов $Q$, начальных ($q_S$) и конечных ($Q_F$) состояний, а так же алфавита $\delta$ и языка $\Sigma$ на котором построено регулярное ограничение. 
    \item Граф, состоящий из множества вершин $V$, множества ребер с метками $E$ и множества допустимых меток $L$.
    \item Начальные вершины графа --- $V_{src}$.
\end{itemize}

Граф декомпозируются по меткам (для каждой метки выделяется граф, состоящий из тех же вершин, что и начальный граф, но из ребер начального графа берутся только ребра с этой меткой), и создаётся множество матриц смежности для каждого получившегося графa $\mathcal{D}^a$. Такая же операция применяется и к графу конечного автомата $\mathcal{G}$.

Далее создаются матрицы, которые будут обновляться каждый шаг алгоритма и хранить текущее состояние: все достижимые вершины на данном шаге алгоритма. Это матрицы обхода $M$ и $M'$, одна пустая (так как на первом же шаге цикла в нее будет записано другое значение), а вторая заполняется следующим образом: для каждого начального состояния конечного автомата все начальные вершины графа помечаются достижимыми.
Так же создается матрица всех посещенных состояний $P$, чтобы в дальнейшем избежать лишних итераций цикла алгоритма.

Основная часть алгоритма --- это обход поиском в ширину, который происходит с использованием умножения матриц. Он продолжается, пока матрица обхода c предыдущего шага $M'$ ненулевая. Каждый шаг матрица обхода с предыдущего шага сохраняется, матрица обхода текущего шага заполняется нулями.

На каждом шагу обхода алгоритм проходит по всем исходящим из вершин, достигнутых на предыдущем шаге, ребрам для каждой метки, одновременно обходится и конечный автомат. Это происходит следующим образом: к матрице обхода состояния $M'$ для каждой метки $a$ аккумулируются состояния, получающиеся из вершин прошлого состояния, которые еще не были посещены (это достигается при помощи умножения на маску посещенных состояний $P$), проходя по ребру, если оно есть и в графе (умножение на $\mathcal{G}^a$), и в графе конечного автомата (умножаем на $\mathcal{D}^a$ на результат прохода по ребру графа). Если по ребру требуется пройти в обратную сторону, то используется транспонированную матрицу графа $(\mathcal{G}^a)^T$ (доказательство корректности операции можно найти в работе в пункте 3.1). 

После этого мы обновляем матрицу посещенных состояний $P$ и вектор финальных состояний $\mathcal{P}$ (дописываем в него, в какой вершине мы достигли какого-то финального состояния конечного автомата).  

Результатом алгоритма является вектор финальных состояний $\mathcal{P}$.

\subsection{Выбор библиотеки булевой линейной алгебры для GPU}

Проанализировав алгоритм, можно составить список необходимых операций, который должна поддерживать искомая библиотека булевой линейной алгебры для GPU. Все перечисленные ниже операции подразумевают умножение и сложение над булевым полукольцом.

\textit{Инвертированной матрицей} для матрицы $A$ называется матрица такого же размера, у которой на месте 1 у матрицы $A$ стоит 0, а на месте 0 --- 1. 

\begin{enumerate}
    \item Перемножение булевых матриц.
    \item Возможность транспонировать и сохранить матрицу.
    \item Поэлементное умножение на инвертированную матрицу.
    \item Поэлементное сложение матриц.
    \item Операция получения количества ненулевых элементов.
    \item Умножение вектора на матрицу.
\end{enumerate}

Также очень важным фактором является формат хранения матриц: ожидается, что алгоритм должен уметь работать с графами, в которых порядка $10^8$ вершин, и если хранить матрицу в виде двумерного массива, то это займет невозможное в нынешнее время количество памяти. 
При этом в алгоритме матрицы преимущественно разреженные, так что рассматривались библиотеки, использующие оптимальные структуры данных для хранения разреженных матриц.

Были найдены следующие библиотеки, подходящие по данному критерию: Spla~\cite{Spla}, Cusp\footnote{Репозитория Cusp на GitHub: \url{https://github.com/cusplibrary/cusplibrary} (Дата посещения: 08.01.2025)}, cuBool~\cite{CuBool}.
Сравнивая их по скорости работы и легкости интеграции и отладки, была выбрана библиотека cuBool по следующим причинам.

\begin{itemize}
    \item Скорость работы\footnote{Тесты производительности cuBool: \url{
https://github.com/SparseLinearAlgebra/cuBool?tab=readme-ov-file\#performance} (Дата посещения: 08.01.2025)}. Это является ключевым требованием, так как хочется добиться максимальной производительности и обрабатывать графы из реального мира.
    \item Её легковесность и сравнительная простота: читабельность кода и возможность быстро разобраться в нем чрезвычайно важны при разработке, так как для достижения максимальной производительность придется отлаживать даже функции внутри самой библиотеки, и необходимо разбираться в том, как они работают. Также библиотека почти не использует сложные API для вычислений на видеокарте, вместо это в ней используется библиотека thrust\footnote{Библиотека thrust: \url{https://developer.nvidia.com/thrust} (Дата посещения: 08.01.2025)}, которая хорошо задокументирована.
    \item Возможность обновлять ее и дописывать свой код.
\end{itemize}

\subsection{Библиотека cuBool}
В этом разделе будет более подробно рассмотрена библиотека cuBool, ее возможности и недостатки.

В cuBool представлены почти все операции булевой линейной алгебры для векторов и матриц. Для матриц это транспонирование, сложение, умножение, как обычное, так и поэлементное, операция взятия столбца или строки как вектор, сложение всех строк, а также произведение Кронекера. Что очень важно, есть операция получения количества ненулевых элементов, и при этом она работает за $O(1)$. Для векторов же это сложение и умножение как вектора на матрицу, так и матрицы на вектор.

Но при наличии большого набора операций нет одной, необходимой для алгоритма: поэлементного умножения на инвертированную матрицу.

Все матрицы в cuBool разреженные, и используется следующий формат хранения: для каждой матрицы хранится множество пар индексов с ненулевыми значениями.  

Для реализации данных операций данная библиотека использует вычислительное API CUDA\footnote{API CUDA: \url{https://developer.nvidia.com/cuda-toolkit} (Дата посещения: 08.01.2025)} от Nvidia, а точнее говоря библиотеку thrust, написанную на CUDA самими разработчиками. Полная и доступная документация thrust\footnote{Документация thrust: \url{https://nvidia.github.io/cccl/thrust/} (Дата посещения: 08.01.2025)} делает разработку на ней быстрой и приятной, а код становится легко читабельным.

В cuBool есть поддержка операций, выполняемых на CPU без использования параллельных вычислений, что конечно не дает желаемой производительности, но позволяет запускаться на платформах, на которых нет графического ускорителя.

Также в cuBool есть удобная система логгирования, сильно облегчающая отладку, а также слежение за выделенной памятью, что помогает избежать её утечек.

Еще одной проблемой стало отсутствие поддержки в последние годы: последний раз cuBool был собран компилятором gcc версии 8 и протестирован на CUDA версии 10.1 (версия датируется 28 июля 2019 года). При тестировании на компьютере с последней версией CUDA 12.6 (от 14 августа 2024 года) и gcc 14.2 возникло большое количество ошибок компиляции.

\subsection{Поэлементное умножение разреженных булевых матриц}

Так как в cuBool не хватает реализации умножения на инвертированную матрицу, необходимо изучить, как реализовать эту операцию, учитывая формат хранения разреженных матриц в cuBool.

Дан простой пример поэлементного умножения матриц.

\begin{align*}
\begin{pmatrix}
  1 & 0 & 0 & 1  \\
  1 & 0 & 0 & 0  \\
  0 & 0 & 1 & 1  \\
  1 & 0 & 1 & 0  \\
\end{pmatrix}
* 
\begin{pmatrix}
  1 & 0 & 0 & 0  \\
  0 & 1 & 1 & 0  \\
  1 & 0 & 0 & 0  \\
  1 & 0 & 1 & 1  \\
\end{pmatrix}
=
\begin{pmatrix}
  1 & 0 & 0 & 0  \\
  0 & 0 & 0 & 0  \\
  0 & 0 & 0 & 0  \\
  1 & 0 & 1 & 0  \\
\end{pmatrix}
\end{align*}

Пусть $C = A * B$. Для каждого элемента итоговой матрицы довольно легко понять, какое значение у него будет. Он равен единице тогда и только тогда, когда у каждой перемножаемой матрицы соответствующие элементы тоже равны единицам.
$$
C_{ij} = 1
\Longleftrightarrow
\begin{cases}
    A_{ij} = 1 \\
    B_{ij} = 1
\end{cases}
$$

Один из оптимальных по памяти форматов представления разреженных матриц это множество пар индексов, в которых элементы отличны от 0. И чтобы вычислить результат поэлементного умножения надо узнать, все пары индексов, которые есть в обоих исходных матрицах, то есть нужно пересечь множества индексов с ненулевыми элементам матриц.

Теперь легко можно вывести правило для поэлементного умножения на инвертированную матрицу.
Все единицу у матрицы $B$ переходят в нули, а нули -- в единицу.
$$
C_{ij} = 1
\Longleftrightarrow
\begin{cases}
    A_{ij} = 1 \\
    B_{ij} = 0
\end{cases}
\Longleftrightarrow
\begin{cases}
    A_{ij} = 1 \\
    B_{ij} \ne 1
\end{cases}
$$

ля получения итоговой матрицы нам нужно узнать все индексы, в которых у элемента первой матрицы значение единица, а у элемента второй матрицы значение 0. Для получения этого множества индексов надо вычесть из множества индексов с ненулевыми элементами первой матрицы множество индексов с ненулевыми элементами второй матрицы.
